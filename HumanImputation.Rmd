---
title: "HumanImputation"
author: "Cas Baptist"
date: "4/5/2022"
output: html_document
---

##### Imputation of testing data 

Testing data makes up 90% of all data from preparation and aggregation stages, and is imputed after blinded training stages to perform cluster analysis of all clusters. Each cluster is formed from grouped genes (by Gene IDs and Ontologies) 

Visualisations may differ depending on the results of the training data (from ImputationBlinded). 

### Prerequisite libraries

```{r, libraries, echo=TRUE}

suppressPackageStartupMessages({
    library(R.utils)
    library(dplyr)
    library(tidyr)
    library(data.table)
    library(RColorBrewer)
    library(gplots)
    library(Polychrome)
    library(purrr)
    library(igraph)
})

source("functions.R")

```

### Load Pre-requisite RDS files 

```{r, loadrds}

normAggScale <- readRDS("normAggScale.rds")
normAggLog <- readRDS("normAggLog.rds")
cutClust <- readRDS("cutClust.rds")
GO_table <- readRDS("GO_table.rds")
##orgGOmatrixwide <-  readRDS("orgGOmatrixwide.rds") 
correlate_melt <-  readRDS("correlate_melt.rds")
hClust <- readRDS("hClust.rds")

```

### 3. Imputation functions

```{r,idk1, echo=TRUE, fig.width=8, fig.height=8}

# A nested list of gene clusters containing the data generated for cluster analysis. 

clust_total = ###

corr_allClusters <- corr_per_clust(normAggLog, cutClust, clust_total)

GOterms_perCl <- GO_per_cl(x=GO_table,
    y=cutClust,
    clust_total = clust_total)

cor_edge_list <- edge_list(corr_allCl=corrAllClusters,
    clust_total = clust_total)

weightorgGOmatrixwide <- impute(GOterms_perCl= GOterms_perCl,
    cor_edge_list = cor_edge_list  ,
    cl_GOall = orgGOmatrixwide, 
    corr_clAll = corrAllClusters,
    clust_total = clust_total,
    thresh = 0.02)

saveRDS(weightorgGOmatrixwide, "weightorgGOmatrixwide.rds")

# Get the list of GO terms per cluster from the original db (before blinding) to use as a reference for filtering the relevant GO terms per cluster. This also makes sure that dimensions (number of columns) in all of the trials are equal.
GOtermsperClust <- GO_per_cl_list(weightorgGOmatrixwide, clust_total)
# Save the list of GO terms per cluster
saveRDS(GOtermsperClust, "GOtermsperClust.rds")

```

### 4. Optimization of parameters

```{r,optimisation}

# Different cluster sizes can produced through passing a list of numbers as denominators of hClust$height  

# Determine min-max cut value to get 20 to 2000 total clusters
clusterVal <- cl_lengthCut(hr=hClust, min=1.297, max=3.378, interval=0.001)
saveRDS(clusterVal, "clusterVal.rds")

# Number of gene IDs with no GO IDs
nullOnt <- setdiff(unique(rownames(normAggScale)),unique(GO_table$ensembl_gene_id))
length(nullOnt)

```


### 1. Cluster Analysis

```{r, clustering}

# Grouping genes by cluster (using cluster 1)
cluster1_list <- names(cutClust[cutClust==1])

# Correlation in Cluster 1  (Function counterpart: corrClust)
cluster_1 <- normAggScale[rownames(normAggScale) %in% cluster1_list,]
corrClust1 <- cor(t(cluster_1))

# GO terms for cluster 1 (Function counterpart: GOperClust)
cluster1GO <- GO_table[GO_table$ensembl_gene_id %in% cluster1_list,]
rownames(cluster1GO) <- cluster1GO[,1] 
cluster1GO[,1] <- c()
cluster1GO <- cluster1GO[,which(colSums(cluster1GO) > 0)]
# Order by row names and column names
cluster1GO <- cluster1GO[order(rownames(cluster1GO)),]
cluster1GO <- cluster1GO[,order(colnames(cluster1GO))]
# Genes of interest for cluster 1
cluster1GO_list <- rownames(cluster1GO)

# List of GeneIDs in the cluster not present in the GO list
diffClust1GO <- setdiff(cluster1_list, cluster1GO_list)

# Use function, wcorr_cluster, to get the weighted values for all blinded genes in cluster 1
cluster1wGO <- weightcorrClust(cluster1_list, corrClust1, cluster1GO)

# Convert output into a data frame with columns as GO terms and rows as gene names
cluster1wGOdf <- as.data.frame(do.call(rbind, cluster1wGO))
cluster1wGOdf <- cluster1wGOdf[order(rownames(cluster1wGOdf)),]
cluster1wGOdf <- cluster1wGOdf[,order(colnames(cluster1wGOdf))]

# Check if the GeneIDs with no GO terms have values
noGOs <- cluster1wGOdf[diffClust1GO,]

# set threshold
Clust1thresh <- 0.02
impClust1df <- (as.matrix(cluster1wGOdf) > Clust1thresh)*1
# Order by row names and column names
impClust1df <- impClust1df[order(rownames(impClust1df)),]
impClust1df <- impClust1df[,order(colnames(impClust1df))]

# Add the GeneIds with no GO terms to the cluster 1 GO terms and set them to zero. This will serve as the input (original) matrix
newRownames <- noGOs*0
input_mat <- rbind(cluster1GO, newRownames)
input_mat <- input_mat[order(rownames(input_mat)),]
input_mat <- input_mat[,order(colnames(input_mat))]

# Check if the rownames of the two dfs are the same. Result should be: integer(0)
which(!rownames(impClust1df) == rownames(input_mat))
which(!colnames(impClust1df) == colnames(input_mat))

# Comparison between input df and resultant df
Clust1neg <- impClust1df - input_mat
Clust1neg[Clust1neg<0] <- 1
which(Clust1neg == -1)

```

### 2. Visualizations

```{r, vis1, echo=TRUE, fig.width=8, fig.height=8}

par(cex.main = 0.5)

colfunc <- colorRampPalette(c("white", "red"))

# create heatmap for input matrix
heatmap.2(as.matrix(input_mat), main="org Cluster 1 GO Terms", scale="none",
    col = colfunc(25), trace="none", 
    margins = c(5,5))

# create heatmap for imputed df
heatmap.2(as.matrix(impClust1df), main="org Cluster 1 Imputed GO Terms", 
    scale="none", col = colfunc(25), trace="none", 
    margins = c(5,5))

# create heatmap for subtraction matrix
heatmap.2(as.matrix(Clust1neg), main="org Cluster 1 GO Terms vs Imputed GO Terms", 
    scale="none", col = colfunc(25), trace="none", 
    margins = c(5,5))

```

### Mem usage

```{r,memusage}
sort( sapply( ls() , function(x) { object.size( get( x ) ) }  )  )
```

### Session Information 

```{r, sessioninfo, echo=FALSE}

sessionInfo()

```
