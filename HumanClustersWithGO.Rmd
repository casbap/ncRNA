---
title: "ClustersWithGO"
author: "Cas Baptist"
date: "4/6/2022"
output: html_document
---

***

##### The following code associates annotations from Gene Ontology to different clusters from the yeast genome using data from DEE2  

***

</br>


### Prerequisite libraries

```{r, Libraries, echo=TRUE}

suppressPackageStartupMessages({
  library(R.utils)
  library(dplyr)
  library(tidyr)
  library(data.table)
  library(RColorBrewer)
  library(gplots)
  library(Polychrome)
  library(edgeR)
  library(GO.db)
  library(gage)
  library(gProfileR)
  library(factoextra)
  library(NbClust)
#  library(org.Sc.sgd.db)
  library(stringi)
  library(biomaRt)
  library(qdapTools)
})

```
</br>

### 1. Load prerequisite files

```{r, load_files, echo=TRUE}

# Load prerequisite objects from DataPrep stage [1]
orgPassWide <- readRDS("orgPassWide.rds")
orgMetadataPass <- readRDS("orgMetadataPass.rds")

```

### 5. Aggregate the SRR run data to SRX experiment (ok)

```{r, SRR_SRX_Aggregation, echo=TRUE}

# Download and read Metadata summary

if (!file.exists("hsapiens_metadata.tsv.cut")){
    download.file("http://ziemann-lab.net/public/cas/rand/hsapiens_metadata.tsv.cut", 
              destfile = "hsapiens_metadata.tsv.cut")}
    
orgMetadata <- read.csv("hsapiens_metadata.tsv.cut", sep = '\t')

# Filter metadata to include only "passed" samples
databasePassList <- colnames(orgPassWide)
orgMetadataPass <- orgMetadata[which(orgMetadata$SRR_accession %in% databasePassList),]

# Assign column 1 as rownames 
rownames(orgMetadataPass) <- orgMetadataPass[,1]
orgMetadataPass <- orgMetadataPass[,-1]

# Sequencing Run aggregate function
srxAgg <- function(x,counts="GeneCounts") {
    IDX=which(names(x) %in% "GeneCounts")
    mds<-x$MetadataSummary
    n=nrow(x[[IDX]])
    SRX_dat <- vapply(X=unique(mds$SRX_accession) ,function(srx) {
        srrs<-rownames(mds)[which(mds$SRX_accession %in% srx)]
        if (length(srrs)>1) {
            rowSums(x[[IDX]][,srrs])
        } else {
            x[[IDX]][,srrs]
        }
    } , numeric(n))
    rownames(SRX_dat) <- rownames(x[[IDX]])
    colnames(SRX_dat) <- unique(mds$SRX_accession)
    SRX_dat
}

# Put the filtered org GeneCount data and the filtered metadata dataframes into a list
orgCountMetadata <- list(GeneCounts = orgPassWide, MetadataSummary = orgMetadataPass)
remove(orgPassWide)
remove(orgMetadataPass)

# Apply both dataframes to the function
agg <- srxAgg(orgCountMetadata)

# Check for samples with zero total counts
colSums(agg) == 0

# Histogram showing samples (columns) counts
hist(colSums(agg), breaks = 30)

# Filtering samples with more than 1 million reads
aggFilterCols <- agg[, which(colSums(agg) >= 1e6)]

# Filtering genes with more than zero counts 
aggFilterRows <- agg[which(rowSums(agg) > 0), ]

# No difference between the filtered and unfiltered columns  
dim(aggFilterCols)
dim(agg)

# Rows ommited for genes with more than zero counts
dim(aggFilterRows)

# Remove unneeded data
remove(orgMetadata)

```

</br>

### 6. Normalisation of Data (ok)

```{r, norm}

# NORMALISATION FOR LIBRARY SIZE BIAS (cpm)
cpm <- cpm(agg)
# add a small number to the entire dataframe to account for zero reads
cpm <- cpm + 0.01
# Filtering to remove lowly expressed genes
thresh <- cpm > 0.6
# check if there are zero values. Result should be FALSE.
all(apply(apply(cpm, 2, function(x) x==0), 2, any))

# Keep genes that have at least 2 TRUEs in each row of thresh
keepthresh <- rowSums(thresh) >= 2

# Subset the rows of data to keep the more highly expressed genes
keepCount <- cpm[keepthresh,]
summary(keepthresh)
dim(keepCount)

# A CPM of 0.6 is used as it corresponds to a count of 10-15 for the library sizes in this data set. If the count is any smaller, it is considered to be very low, indicating that the associated gene is not expressed in that sample. As a general rule, a good threshold can be chosen by identifying the CPM that corresponds to a count of 10, which in this case is about 0.6. You should filter with CPMs rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples.

# Note: When in doubt, a threshold of 1 CPM in at least minimum group sample size is a good rule of thumb.

# Check whether our threshold of 0.6 does indeed correspond to a count of about 10-15
# Add a vertical line at 0.6 CPM, and a horizontal line at Counts = 10
plot(cpm[,1], agg[,1], ylim=c(0,50), xlim=c(0,3), 
  abline(v=0.6, h=10, col="blue"), 
  ylab = "Counts", xlab = "CPM", 
  main = "Counts-per-million (CPM) vs Counts")
remove(cpm)

# Convert counts to DGEList object (from edgeR library)
dgeObj <- DGEList(keepCount)

#NORMALISATION FOR COMPOSITION BIAS (TMM normalisation)
# Apply normalisation to DGEList object
dgeObj <- calcNormFactors(dgeObj) 
# dgeObj$samples

# Get log2 counts per million
normAgg <- cpm(dgeObj,log=TRUE)
remove(dgeObj)

# Check distributions of samples
hist(normAgg)
hist(keepCount)
remove(keepCount)
all(apply(apply(normAgg, 2, function(x) x==0), 2, any))

```

</br>

### 8. Heirarchical Clustering with PASS only databases (ok)

```{r, heirarchical_cluster, echo=TRUE}

# Applying Hierarchical Clustering after normalization
distClust <- as.dist(1-cor(t(normAgg), method="spearman"))
hClust <- hclust(distClust , method="complete")
remove(distClust)

# optimizing the cluster size
clusterPass <- cutree(hClust, h=max(hClust$height/1.64))
clusterPasslength <- length(unique(clusterPass))

if (!exists("P100")){
  P100 <- createPalette(100,  c("#ff0000", "#00ff00", "#0000ff"))}

clusterCols <- P100[1:clusterPasslength]
myClusterSideBar <- clusterCols[clusterPass]
colfunc <- colorRampPalette(c("blue", "white", "red"))
if (!file.exists("Data/org_se.tsv")){
  write.table(clusterPass,file="Data/org_pass.txt",quote=F,sep="\t")}

# create a 5 x 5 inch png image
png("Data/org_heatmaps_PASS_normalization3.png", 
  width = 5*300, height = 5*300, res = 300, pointsize = 8)          

# create the heatmap
heatmap.2(normAgg, main="org PASS Samples",  Rowv=as.dendrogram(hClust),
          dendrogram="both", scale="column", col = colfunc(25), trace="none", 
          RowSideColors= myClusterSideBar, margins = c(5,5))

dev.off()

```

</br>

### 10. Blinding genes using random strings

```{r, blinding}

#Fraction of the total number of genes to be blinded
fracBlind <- 0.10
numGenes <- round(nrow(agg)*fracBlind)

blind <- sample(rownames(agg), numGenes)

rand <- stri_rand_strings(numGenes, 15, pattern = "[A-Za-z]")
rand <- paste("blind_", rand, sep = "")
dictBlind <- data.frame(blind, rand)

# save the dictionary into an RDS file
saveRDS(dictBlind, "dictBlind.rds")

indBlind <- which(rownames(agg) %in% blind)

rownames(agg)[indBlind] <- rand

remove(agg)

```

</br>

### 11. Functions for Cluster Analysis 

```{r, func1}

# This function's output is a nested list with of the genes grouped per cluster and 
# their corresponding correlation values. Inputs:
# x = normAgg (normalized gene counts from RNA seq)
# y = clusters (matrix of genes w/ cluster number)
# clust_total = total number of clusters

corrClust <- function(x, y, clust_total){
  corrClust <- list()
  for (i in 1:clust_total){
    cluster_list <- names(y)[which(y == i)]
    cluster <- x[rownames(x) %in% cluster_list,]
    corr_result <- cor(t(cluster))
    corrClust[[paste0("Cluster", i)]] <- corr_result
  }
  return(corrClust)
}

corrAllClusters <- corrClust(normAgg, clusterPass, 100)
saveRDS(corrAllClusters,"corrAllClusters.rds")
remove(normAgg)

```

```{r, func2}

# This function's output is a list of data frames containing all GO terms 
# associated with the genes belonging to a cluster. Input:
# x = orgGOmatrixwide (matrix of genes belonging to a GO term)
# y = clusters (matrix of genes w/ cluster number)
# clust_total = total number of clusters

GOperClust <- function(x,y,clust_total){
  GOClust <- list()
  for (i in 1:clust_total){
    cluster_list <- names(y)[which(y == i)]
    cluster_GOterms <- x[x$ensembl_gene_id %in% cluster_list,]
    rownames(cluster_GOterms)<- cluster_GOterms[,1] 
    cluster_GOterms[,1] <- c()
    cluster_GOterms <- cluster_GOterms[,which(colSums(cluster_GOterms) > 0)]
    GOClust[[paste0("Cluster", i)]] <- cluster_GOterms
  }
  return(GOClust)
}

orgGOmatrixwide <- readRDS("orgGOmatrixwide.rds")
GOallClusters <- GOperClust(orgGOmatrixwide, clusterPass, 100)
saveRDS(GOallClusters,"GOallClusters.rds")
remove(orgGOmatrixwide)

### Session Information 

```{r Session Info, echo=FALSE}

sessionInfo()

```
